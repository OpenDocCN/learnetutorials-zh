<html>
<head>
<title>Python Overloading And Overriding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Python 重载和重写</h1>
<blockquote>原文:<a href="https://learnetutorials.com/python/method-overloading-overriding">https://learnet utortials . com/python/method-重载-覆盖</a></blockquote>&#13;
                        &#13;
                       <!-- Content Area -->&#13;
&#13;
&#13;
                       <p>在本教程中，您将掌握面向对象编程的另一个重要概念，即 python 中的<strong>多态性</strong>。您将了解什么是多态性，在编程中实现多态性的不同方式。此外，您将详细掌握重载和重写的概念。</p>

<h2>python 中什么是多态性？</h2>

<p>多态性是面向对象编程的基本构件之一。为了更清楚地理解它，让我们把多态这个词分解成多态和态射。通俗地说，poly 表示多，morph 表示形式。所以多态性意味着多种形式。</p>

<div class="img-div"><img alt="Polymorphism in python" src="../Images/b0e6afdc03d3498cb18408d6f0d16a17.png" data-original-src="https://559987-1802630-raikfcquaxqncofqfm.stackpathdns.com/assets/images/tutorials/over/poly.png"/>
<h3>python 中的多态性</h3>
</div>

<p>在编程中，多态性可以被定义为一个实体有多种形式的过程。专门处理对象的 Python 显示了对象的多态性，这意味着对象有多种形式。</p>

<p>在现实生活中，我们人类是多态的，因为我们在不同的情况下表现不同。例如，我们在办公室和家里的行为不同。</p>

<h2 id="duck">什么是 python 中的鸭子打字？</h2>

<p>鸭分型是实现多态性的一种方式，与动态分型有很大关系。鸭子打字得名于一句名言“<strong>如果一个东西走路像鸭子，嘎嘎叫像鸭子，游泳像鸭子，那么它应该是一只鸭子</strong>”。这意味着，行为像鸭子的东西应该是鸭子。例如，如果一个人像鸭子一样走路，像鸭子一样游泳，那么这个人可能就是鸭子。</p>

<p>支持<strong>动态打字</strong>的 Python、Javascript 等编程语言广泛使用了鸭子打字的概念。这些语言的独特和共同特点是它们没有显式声明变量类型。如果我们将同一个变量赋给另一个数据类型，编译器不会产生错误。观察以下示例:</p>

<div class="code-example">
<pre>
<code class="python">x = 5
print(type(x))
x = 'Learn eTutorial'
print(type(x))
</code>
</pre>
</div>

<p><strong>输出:</strong></p>

<div class="output">
<pre>
<samp>
&lt;class 'int'&gt; 
&lt;class 'str'&gt;
</samp></pre>
</div>

<p>这里我们首先给变量<strong> x </strong>赋值整数值<strong> 5 </strong>，使其成为一个<code>int</code>类型。稍后，我们用字符串值“<strong>Learn ettorials</strong>”重新分配同一个变量，使其成为<strong>字符串</strong>类型。这表明动态类型适用于诸如 int、str、list 等内置类。</p>

<p>同样，我们可以借助 duck type 在自定义类上实现动态类型化，在 duck type 中，突出<strong>方法和属性</strong>的存在，我们不检查类型和类，因为它们不太重要。</p>

<div class="code-example">
<pre>
<code class="python">class Duck:
    def walk_swim(self):
        print("I'm a duck, and I can walk and swim.")

class Robot:
     def walk_swim(self):
         print("I'm a Robot, and I can walk and swim.")

class Fish:
     def swim(self):
         print("I'm a fish, and I can swim, but not walk.")
 
for bird in Duck(),Robert(),Fish():
    bird.walk_swim() </code>
</pre>
</div>

<p><strong>输出:</strong></p>

<div class="output">
<pre>
<samp>I'm a duck, and I can walk and swim.
I'm a Robot, and I can walk and swim.
Traceback (most recent call last):
  File "poly_ex.py", line 118, in <module>
    bird.walk_swim()
AttributeError: 'Fish' object has no attribute 'walk_swim'
</module></samp></pre>
</div>

<p>在上面的代码片段中，<strong>鸟</strong>是每个类的对象，并且正在测试每个类中<code>walk_swim()</code>方法的存在。鸭子班通过了测试，因为它肯定会走路和游泳。机器人类也是如此，因为它也实现了<code>walk_swim()</code>方法。但是 Fish 类以错误告终，因为它没有通过鸭子测试评估，因为它没有实现<code>walk_swim()</code>方法。</p>

<p>duck 类型的实际应用是迭代器、可调用和<code>len()</code>方法的排序。关键的一点是，当使用 duck 类型时，我们传递的是哪个类对象并不重要，重要的是对象应该有相关的方法。</p>

<h2 id="overloading">python 中什么是运算符重载？</h2>

<p>在 python 中实现多态性的另一种方式是通过使用运算符重载。回想一下什么是操作员。任何执行某种计算的唯一符号都被称为运算符。所以<strong>运算符重载</strong>是根据所使用的操作数，以多种形式使用同一个运算符(比如+)的过程。查看下面显示运算符“+”行为变化的代码片段:</p>

<div class="code-example">
<pre>
<code class="python">a = 1
b = 2
print(a+b)

c ='Python'
print(c*3)

d = 'Programming'
e = 'Language'
print(d+e) </code>
</pre>
</div>

<p><strong>输出:</strong></p>

<div class="output">
<pre>
<samp>3
PythonPythonPython
ProgrammingLanguage
</samp></pre>
</div>

<p>这里<strong>加运算符</strong>对两个整数执行加法，同时对两个字符串执行串联。</p>

<p>你可能想知道这是怎么可能的，在这个操作员背后到底发生了什么。让我们将两个整数相加，并在内部分解，以了解这些整数背后的过程。</p>

<p>永远记住，python 中发生的任何事情都是基于对象的。这里<strong> a+b </strong>是有两个操作数的表达式，操作数 a 和 b 是‘int’类型，内部意思是 a 和 b 是<strong>类 int </strong>的两个属性。显然，这个类必须有一些方法来计算它的操作数。所以当你使用<strong> a+b </strong>的时候，python 内部调用<strong>魔法方法</strong> - int。__ 添加 __(a，b)方法。</p>

<div class="code-example">
<pre>
<code class="python">a = 1
b = 2
print(int.__add__(a,b))

c ='Python'
print(str.__mul__('Python',3))

d = 'Programming'
e = 'Language'
print(str.__add__('Programming','Language')) </code>
</pre>
</div>

<p><strong>输出:</strong></p>

<div class="output">
<pre>
<samp>3
PythonPythonPython
ProgrammingLanguage
</samp></pre>
</div>

<p>所以当你使用</p>

<ul>
 <li>+运算符它调用一个<code>obj.__add__()</code>方法。</li>
 <li>-操作员调用<code>obj.__sub__()</code>方法。</li>
 <li>*操作员调用一个<code>obj.__mul__()</code>方法。</li>
</ul>

<p>在 python 中，运算符重载适用于内置类，如 int、str、list 等。然而，我们也可以将操作符的可操作性扩展到用户定义的类。这可以使用运算符重载来实现。</p>

<div class="code-single error">
<pre>
<code class="python">class Quantity:
    def __init__(self,w1,w2):
        self.w1=w1
        self.w2=w2

    def __str__(self):
        return "{} ,{}".format(self.w1,self.w2)

q1=Quantity(5,6)
q2=Quantity(7,8)

print(q1)
print(q2)

print(q1+q2)

</code>
</pre>
</div>

<p><strong>输出:</strong></p>

<div class="output">
<pre>
<samp>(5 ,6)
(7 ,8) 
Traceback (most recent call last):
  File "poly_ex.py", line 51, in <module>
    print(q1+q2)
TypeError: unsupported operand type(s) for +: 'Quantity' and 'Quantity'
</module></samp></pre>
</div>

<p>让我们打破这个例子来清楚地理解它。</p>

<ul>
 <li>我们定义了一个名为<strong>数量</strong>的类，它有两个属性<strong> w1 </strong>和<strong> w2 </strong>。</li>
 <li><code>__str__()</code>方法的工作原理与打印功能相同。此方法返回指定的数量。</li>
 <li><strong> q1 </strong>和<strong> q2 </strong>是我们分别用两个不同的量(5，6)和(7，8)创建的两个实例。</li>
 <li>接下来，我们尝试单独和组合打印实例中的属性。</li>
 <li>从示例中可以很清楚地看到，print(q1)和 print(q2)工作顺利，但是 print(q1+q2)语句引发了名为<strong> Type Error </strong>的错误。这是因为我们没有定义要对操作数执行的操作，它只对内置类有效。</li>
</ul>

<p>那么如何以用户自定义的方式实现操作者的可操作性呢？我们只需要在类中定义一个额外的方法，使得+运算符可以在对象上工作。为此，我们在课堂上实现了神奇的方法<code>__add__()</code>。</p>

<div class="code-example">
<pre>
<code class="python">class Quantity:
    def __init__(self,w1,w2):
        self.w1=w1
        self.w2=w2

    def __str__(self):
        return "{} ,{}".format(self.w1,self.w2)

    def __add__(self,other):
        w1=self.w1+other.w1
        w2=self.w2+other.w2
        return (w1,w2)

q1=Quantity(5,6)
q2=Quantity(7,8)

print(q1)
print(q2)

print(q1+q2) </code>
</pre>
</div>

<p><strong>输出:</strong></p>

<div class="output">
<pre>
<samp>(5 ,6)
(7 ,8)
(12, 14)
</samp></pre>
</div>

<p>当您调用 print(q1+q2)时，python 会调用方法来添加 Quantity 形式的方法。__ 添加 __(q1，q2)，相当于 q1。__ 添加 __(q2)。</p>

<h2 id="magic">Python 中的神奇方法</h2>

<p><strong> Magic </strong>或<strong> Dunder </strong>方法是 python 中任何添加双下划线的方法。邓德缺<strong> D </strong>双<strong>下</strong>。下表列出了 python 中使用的一些常见魔术方法。</p>

<table>
 <tbody>
  <tr>
   <th>操作员</th>
   <th>表示</th>
   <th>神奇的方法</th>
  </tr>
  <tr>
   <td>添加</td>
   <td>q1+ q2</td>
   <td>ob . _ _ _ add _(Q1、q2)</td>
  </tr>
  <tr>
   <td>减法</td>
   <td>Q1–Q2</td>
   <td>页:1</td>
  </tr>
  <tr>
   <td>增加</td>
   <td>q1 * q2</td>
   <td>ob . _ _ _ mul _(Q1、q2)</td>
  </tr>
  <tr>
   <td>分开</td>
   <td>q1 / q2</td>
   <td>ob . _ _ _ true div _(Q1，q2)</td>
  </tr>
  <tr>
   <td>力量</td>
   <td>q1 ** q2</td>
   <td>是吗？_ _ _ _ _ pow _(Q1，q2)</td>
  </tr>
  <tr>
   <td>楼层划分</td>
   <td>q1 // q2</td>
   <td>是吗？_ _ _ flood v _(Q1、q2)</td>
  </tr>
  <tr>
   <td>模运算符</td>
   <td>q1 % q2</td>
   <td>ob . _ _ _ mod _(Q1、q2)</td>
  </tr>
  <tr>
   <td>按位左移</td>
   <td>q1 &lt;&lt; q2</td>
   <td>ob . _ _ _ lshift _(Q1，q2)</td>
  </tr>
  <tr>
   <td>按位右移</td>
   <td>q1 &gt;&gt; q2</td>
   <td>ob . _ _ _ rsift _(Q1，q2)</td>
  </tr>
  <tr>
   <td>按位非</td>
   <td>~q1</td>
   <td>ob . _ _ _ _ _ _ _(Q1)</td>
  </tr>
  <tr>
   <td>按位“与”</td>
   <td>q1 和 q2</td>
   <td>卒于 __ 和 __(q1，q2)</td>
  </tr>
  <tr>
   <td>按位“或”</td>
   <td>q1 | q2</td>
   <td>卒于 __ 或 __(q1，q2)</td>
  </tr>
  <tr>
   <td>按位异或</td>
   <td>q1 ^ q2</td>
   <td>ob . _ _ _ _ _ _ _(Q1，q2)</td>
  </tr>
  <tr>
   <td>不到</td>
   <td>q1 &lt; q2</td>
   <td>页:1</td>
  </tr>
  <tr>
   <td>小于等于</td>
   <td>q1 &lt;= q2</td>
   <td>是吗？_ _ _ _ _ _(Q1，q2)</td>
  </tr>
  <tr>
   <td>大于</td>
   <td>q1 &gt; q2</td>
   <td>页:1</td>
  </tr>
  <tr>
   <td>大于等于</td>
   <td>q1 &gt;= q2</td>
   <td>ob . _ _ _ ge _(Q1、q2)</td>
  </tr>
  <tr>
   <td>等于</td>
   <td>q1 == q2</td>
   <td>ob . _ _ _ eq _(Q1，q2)</td>
  </tr>
  <tr>
   <td>不等于</td>
   <td>q1！= q2</td>
   <td>页:1</td>
  </tr>
 </tbody>
</table>

<h2 id="or">Python 方法/函数重载</h2>

<p><strong>方法重载</strong>在面向对象编程中，是一种方法根据传递给该方法的参数表现不同的能力。方法重载支持<strong>编译时多态性</strong>。</p>

<p>很明显，如果一个类有两个同名的方法和不同数量的参数，那么这个方法就是重载的。观察下面的代码片段:</p>

<div class="code-example">
<pre>
<code class="python">class A:
    def add(self,a,b):
        s = a+b
        print(s)
    def add(self,a,b,c):
        s = a+b+c
        print(s) </code>
</pre>
</div>

<p>这里我们有一个名为<strong> A </strong>的类，有两种方法。两种方法使用相同的名称，即<strong> add() </strong>但是两种方法中的参数数量不同。一个方法有两个参数，而另一个方法有三个参数。这里<strong> add()的方法是重载</strong>。</p>

<p>现在让我们检查一下在 python 中执行时它的输出会是什么。</p>

<div class="code-single error">
<pre>
<code class="python">class A:
    def add(self,a,b):
        s = a+b
        print(s)
    def add(self,a,b,c):
        s = a+b+c
        print(s)

ob = A()
ob.add(10,20)
 </code>
</pre>
</div>

<div class="output">
<pre>
<samp>Traceback (most recent call last):
  File "poly_ex.py", line 73, in <module>
    ob.add(10,20)
TypeError: add() missing 1 required positional argument: 'c'
</module></samp></pre>
</div>

<p>这里发生的事情是，由于两个方法具有相同的名称<strong>，python 保留了类</strong>中定义的最新方法，当进行函数调用时，它会检查最新的方法，即具有三个参数的方法。带有两个参数的 add()在类中保持不变。这意味着 python 不支持方法重载，不像其他 oop 语言。</p>

<div class="note">
<p>注意:Python 不支持方法重载。</p>
</div>

<p>然而，幸运的是，我们有一种 python 方式来实现 python 中的方法重载。</p>

<div class="code-example">
<pre>
<code class="python">class A:
    def add(self,a = None,b = None, c = None):
        if a!=None and b!=None and c!=None:
         print (a+b+c)
        else:
         print(a+b)
    
ob = A()
ob.add(10,20)
ob.add(30,40,50)
ob.add('Programming','Tutorials') </code>
</pre>
</div>

<p><strong>输出:</strong></p>

<div class="output">
<pre>
<samp>30
120
ProgrammingTutorials
</samp></pre>
</div>

<p>上面的代码片段显示了如何通过一些技巧在 python 中实现方法重载。这里我们可以用三种不同的方式调用 add()方法。</p>

<ul>
 <li>ob.add(10，20)</li>
 <li>ob.add(30、40、50)</li>
 <li>ob.add('编程'，'教程')</li>
</ul>

<p>让我再次提醒您，这不是实现方法重载的理想方式，因此不是 python 中的方法重载。但不知何故，我们在 python 中实现了方法重载。</p>

<h2 id="overriding">python 中的方法覆盖是什么？</h2>

<p><strong>在面向对象编程语言中，覆盖</strong>是支持<strong>运行时多态性</strong>的一个重要概念。当子类中的方法与其父类中的方法具有相同的名称<strong>、相同数量的参数</strong>和相同的返回类型<strong/>(签名)时，该方法被称为<strong>覆盖了</strong>。方法重写的主要好处是，子类可以为继承的方法提供自己的特定实现，甚至不需要更改父类方法。</p>

<p>因此在方法重写中，我们有两个方法，一个在父类中被称为<strong>重写方法</strong>，一个在子类中被称为<strong>重写方法</strong>的继承方法。两种方法具有相同的名称和签名。</p>

<h2 id="example">方法覆盖示例</h2>

<p>为了使它更容易理解，检查一下有两个类的简单例子:父类- <strong>妈妈</strong>和子类- <strong>女儿</strong>。</p>

<div class="code-example">
<pre>
<code class="python">#Parent Class 
class Mom:
    def dance(self):
        print("Mom is dancing")
    def cook(self):
        print("Mom is cooking")    

#Child class
class Daughter(Mom):
        pass
   
d = Daughter()
d.dance()
d.cook() </code>
</pre>
</div>

<p><strong>输出:</strong></p>

<div class="output">
<pre>
<samp>Mom is dancing
Mom is cooking
</samp></pre>
</div>

<p>父类包含两种方法:<strong> dance() </strong>和<strong> cook() </strong>打印一些消息。现在，我们保持子类为空，没有任何方法或属性，但是我们创建了一个子类的对象，并使用它来调用 Mom 中的方法。因为女儿继承自妈妈，所以它可以访问妈妈类中的方法并产生输出。</p>

<p>让我们创建覆盖 dance()方法的子类“女儿”。</p>

<div class="code-example">
<pre>
<code class="python">#parent class
class Mom:
    #overridden method
    def dance(self):
        print("Mom is dancing")
    def cook(self):
        print("Mom is cooking")    

#child class
class Daughter(Mom):
    #overriding method
    def dance(self):
        print("Daughter is dancing ")

d = Daughter()
d.dance()
d.cook() </code>
</pre>
</div>

<p><strong>输出:</strong></p>

<div class="output">
<pre>
<samp>Daughter is dancing
Mom is cooking
</samp></pre>
</div>

<p>现在当我们调用对象 d 时，<strong> dance() </strong>方法的修改版本将执行，这在输出中得到了清晰的体现。因此，我们可以得出结论，子类覆盖了妈妈类的方法。</p>
                       &#13;
                       &#13;
                       <!-- End Content Area -->&#13;
&#13;
                        
</body>
</html>